
```python
from collections import deque


def find_start(maze):
    """找到起点 'S' 的位置"""
    for i in range(len(maze)):
        for j in range(len(maze[i])):
            if maze[i][j] == 'S':
                return (i, j)
    return None


def find_path(maze, directions):
    """
    使用 BFS 找到从 'S' 到 '#' 的最短路径
    :param maze: 迷宫二维列表
    :param directions: 自定义方向键，格式: [(dx, dy, '方向符号'), ...]
    :return: 路径（方向列表）
    """
    start = find_start(maze)
    if not start:
        return None

    rows, cols = len(maze), len(maze[0])
    queue = deque([(start[0], start[1], [])])  # (row, col, path)
    visited = set([(start[0], start[1])])

    while queue:
        x, y, path = queue.popleft()

        if maze[x][y] == '#':
            return path  # 找到终点，返回路径

        for dx, dy, dir in directions:
            nx, ny = x + dx, y + dy
            if (
                    0 <= nx < rows and 0 <= ny < cols
                    and maze[nx][ny] != '*'  # 不是墙
                    and (nx, ny) not in visited
            ):
                visited.add((nx, ny))
                queue.append((nx, ny, path + [dir]))

    return None  # 没有找到路径


def print_maze_with_path(maze, path, directions):
    """打印迷宫，并标记路径"""
    start = find_start(maze)
    if not start:
        print("迷宫没有起点 'S'！")
        return

    x, y = start
    maze_copy = [row.copy() for row in maze]  # 复制迷宫，避免修改原数据

    # 标记路径（用 '.' 表示）
    for step in path:
        for dx, dy, dir in directions:
            if step == dir:
                x += dx
                y += dy
                if maze_copy[x][y] != '#':  # 不覆盖终点 '#'
                    maze_copy[x][y] = '.'
                break

    # 打印迷宫
    for row in maze_copy:
        print(' '.join(row))


# 迷宫数据
maze = [
    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],
    ['*', 'S', '0', '0', '0', '*', '0', '0', '0', '0', '0', '0', '0', '*', '*'],
    ['*', '0', '*', '*', '0', '0', '0', '*', '*', '*', '*', '*', '0', '*', '*'],
    ['*', '0', '*', '0', '0', '*', '0', '*', '0', '0', '0', '*', '0', '*', '*'],
    ['*', '0', '0', '0', '*', '*', '0', '*', '0', '*', '0', '*', '0', '*', '*'],
    ['*', '0', '*', '*', '*', '0', '0', '*', '0', '*', '0', '*', '0', '0', '*'],
    ['*', '0', '*', '*', '*', '0', '*', '*', '0', '*', '0', '*', '*', '0', '*'],
    ['*', '0', '0', '0', '*', '0', '*', '0', '0', '*', '0', '0', '*', '0', '*'],
    ['*', '*', '*', '0', '*', '0', '*', '*', '*', '*', '*', '*', '0', '#', '*'],
    ['*', '*', '*', '0', '*', '0', '0', '0', '0', '0', '0', '0', '0', '*', '*'],
    ['*', '0', '0', '0', '*', '*', '*', '*', '*', '*', '*', '*', '0', '*', '*'],
    ['*', '0', '*', '*', '*', '0', '0', '0', '0', '0', '*', '0', '0', '*', '*'],
    ['*', '0', '*', '0', '*', '*', '*', '*', '*', '0', '*', '*', '0', '*', '*'],
    ['*', '0', '0', '0', '0', '0', '0', '0', '*', '0', '0', '0', '0', '0', '*'],
    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*']
]

# 自定义方向键（可以改成 WASD 或 ↑↓←→）
# 格式: (行变化, 列变化, '方向符号')
custom_directions = [
    (-1, 0, 'U'),  # 上 (W)
    (1, 0, 'D'),  # 下 (S)
    (0, -1, 'L'),  # 左 (A)
    (0, 1, 'R')  # 右 (D)
]

# 计算路径并打印
path = find_path(maze, custom_directions)
if path:
    print("找到路径！路径方向：", ''.join(path))
    print("\n迷宫路径（'.' 表示路径）：")
    print_maze_with_path(maze, path, custom_directions)
else:
    print("没有找到路径！")
```
