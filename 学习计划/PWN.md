## Week 1：栈溢出基础 & 环境搭建

| **Day** | **任务及练习题**                                                                                                                                                                                                                                        | **关键点**                                                                                                                                                                                                                                                            | **参考资料**                                                |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------- |
| **1**   | **环境搭建与基础预习：** – 搭建Ubuntu/Linux工作环境，安装`gcc`、`gdb`、`pwndbg`/`GEF`调试插件、IDA/Ghidra反汇编工具、Python3及`Pwntools`库。 – 学习C语言指针与内存简单示例（如编写并运行一个缓冲区溢出小程序）。 – 熟悉Linux基本命令（如`file`查看文件信息, `chmod`赋予可执行权限等）。                                                      | _目标：完成比赛所需环境配置，能够编译运行简单C程序；理解栈内存基本概念（栈帧、返回地址）。_ 在笔记中记录环境配置要点及遇到的问题解决方案。                                                                                                                                                                                            | 安装指南参考：（Ubuntu下gcc/gdb配置）栈基础知识参考：（PWN题目模式简介）            |
| **2**   | **练习题：**NSSCTF/BUUCTF入门题 – _“test_your_nc”_ 或 Bugku _“pwn1”_（简单服务连接） – **任务：**使用`nc`连接远程服务，根据提示获取flag。 – **预习：**学习Netcat基本用法，了解CTF中文件/服务交互方式。                                                                                                     | _关键点：_ 熟悉题目平台界面和提交Flag流程；体会CTF PWN题通常提供远程服务和本地文件两部分。 *步骤：*用`nc <host> <port>`连接题目服务，尝试输入简单命令（如`ls`）查看响应。该题目属于“服务端直接给Shell”，预期直接执行`cat flag`输出flag。 *拓展：*思考为什么服务会直接给shell权限（了解程序可能直接调用了`system("/bin/sh")`）。                                                        | 题目Writeup参考：（利用nc交互获取flag）Netcat用法教程:《NC简单实用指南》         |
| **3**   | **练习题：**BUUCTF _“rip”_ （基础栈溢出） – **任务：**通过缓冲区溢出修改返回地址，调用隐藏的`fun()`函数获取shell。 – **预习：**阅读CTF Wiki栈溢出基础，理解`gets()`不安全原理。 – **操作：**使用IDA静态分析binary找出`fun()`函数地址，利用GDB调试确定溢出偏移，构造输入payload跳转。                                                         | _关键点：_ 理解函数调用栈布局（局部变量在栈中连续分配，超范围写入会覆盖返回地址）。识别危险函数`gets()`无长度检查，存在栈溢出漏洞。 *利用思路：*覆写返回地址为`fun()`函数入口地址。实践中，使用`python -c 'print("A"*偏移 + 新返回地址)'`构造输入。 *工具体验：*在GDB中设置断点观察栈变化，练习使用`pattern_create`等插件查找精确偏移。                                                            | WP参考：（分析`fun()`函数作用及栈溢出思路）栈溢出基础原理: CTF Wiki《栈溢出原理》      |
| **4**   | **练习题：**Bugku _“pwn2”_ （栈溢出调用shell） – **任务：**溢出缓冲区并覆盖返回地址，跳转执行程序内置的`get_shell`函数。 – **分析：**用IDA看`main`函数，找到`gets`输入和`get_shell`函数地址。 – **利用：**计算溢出偏移（可用GDB或pattern工具），构造payload：填充“垃圾值”到返回地址，再写入`get_shell`的地址，实现函数跳转。                            | _关键点：_ 掌握利用程序自带“后门函数”的思路：很多CTF新手题在binary中留有`system("/bin/sh")`或`get_shell()`函数，可通过修改返回地址直接调用。 *技能：*使用`objdump -d`或IDA查看函数地址；用GDB调试时`info functions`列出符号表中的函数。 _验证：_ 本地运行payload获取shell，成功后用`nc`连接远程服务提交payload拿flag。                                               | 题解参考：（包含main函数关键片段和payload构造）Exploit示例：（简要的payload构造示例） |
| **5**   | **练习题：**BUUCTF _“warmup_csaw_2016”_（64位栈溢出） – **任务：**经典CTF题，64位程序无保护，利用溢出调用`system("cat flag.txt")`拿flag。 – **步骤：**运行文件观察提示（可能输出了某地址）；使用GDB确定溢出所需字节数，找到存在`system`调用的函数。 – **利用：**填充缓冲区至返回地址，覆盖为目标函数地址，并确保对齐栈以避免崩溃（64位栈需16字节对齐）。                   | _关键点：_ 练习64位环境下栈溢出，注意寄存器传参：`system`函数的第一个参数`/bin/sh`需放入RDI寄存器。这题若已有函数直接调用了`system("cat flag.txt")`，则简单跳转即可；如需自己调用`system("/bin/sh")`，需ROP链（Week2学习）。 *ID技巧：*用IDA查看函数伪代码快速理解逻辑。 *对齐问题：*了解栈对齐的重要性：若栈未按16字节对齐，某些系统函数可能崩溃。解决办法是在payload中加入一个ret gadget或填充字节使栈对齐到16的倍数。 | 官方Writeup参考：（简述利用思路）64位ROP注意事项：（栈对齐及ROP链格式）             |
| **6**   | **调试工具实践：** – 选择前面尚未深入理解的一题（如“rip”或“warmup_csaw_2016”），使用GDB复现漏洞过程：设置断点在溢出点，观察栈内容变化和EIP/RIP被覆盖情况。 – 学习使用`pwndbg`/`GEF`调试插件的常用命令（如查看寄存器`info reg`、栈内存`dx`、启用`context`窗口）。 – 初步使用`Pwntools`库：编写一个Python脚本，用`pwntools.remote`连接前几日的远程服务，实现自动化获取flag。 | *目的：*熟练掌握基本调试技能，加深对缓冲区溢出原理的理解。从实践中看到，当输入长度超过缓冲区时，返回地址如何被覆盖为我们指定的值。 *练习：*在GDB里使用`pattern_create`/`pattern_offset`寻找精确覆盖位置；观察GDB报错信息，如出现`Segmentation fault`，用`info frame`查看寄存器了解崩溃原因。 *Pwntools：*练习用Python脚本替代手工`nc`操作，例如自动发送payload并接收flag，体会脚本化带来的效率提升。           | GDB教程：（简单GDB使用过程）pwndbg文档：“pwndbg参考手册”                  |
| **7**   | **知识回顾与笔记整理：** – 回顾Week1所学知识点：栈溢出基本概念、利用步骤（找偏移->改返回地址）、32位与64位差异、工具使用心得。 – 列举本周出现的函数和漏洞：如`gets`、`strcpy`导致的溢出，记录这些不安全函数。 – 对照WP检查是否有未理解细节，整理在笔记中（如“如何计算偏移”“函数调用约定”）。 – 确保环境配置完善，为下周挑战更难题目做好准备。                                                    | *关键点：*通过总结强化记忆。将每道题的思路凝练成攻略：输入如何触发漏洞，如何定位覆盖位置，payload构造格式。 *反思：*统计本周遇到的困难（比如不会查看寄存器、不理解某段汇编），计划下一步改进。 *笔记模版：*建议按题目记录“漏洞点、利用方法、关键函数地址、脚本”等，方便日后快速复习。                                                                                                                | 新手总结示例参考：（博客作者的PWN入门心得）CTF经验谈：（跟随WP学习与总结的重要性）           |
## **Week 2：栈溢出进阶 (Ret2libc 等)**
|**Day**|**任务及练习题**|**关键点**|**参考资料**|
|---|---|---|---|
|**1**|**预习 & 基础巩固：** – 阅读CTF Wiki关于**函数调用约定**和**64位寄存器**的章节，理解函数参数传递（x64系统前6个参数在寄存器，32位在栈上传递）。 – 学习常见防护机制：NX（栈不可执行）意味着不能直接执行shellcode，需要借助已存在函数；了解Canary、ASLR基础概念（本日不深入利用）。 – 准备Ret2libc所需基础：知道什么是libc库，熟悉`system`、`puts`、`gets`等函数在libc中的作用。|*目标：*为接下来Ret2libc练习打好基础。 *要点：*NX保护启用时，注入shellcode将失败，需转而利用libc现有代码。Ret2libc典型思路：泄露libc基址->计算`system`地址->构造调用。 *工具：*安装并熟悉`libcSearcher`工具的用法：给定已泄露的地址自动匹配对应libc版本，获取`system`和`/bin/sh`偏移。|调用约定参考：（栈帧和寄存器介绍）防护机制科普：（提及NX/ASLR等在PWN中的作用）|
|**2**|**练习题：**BUUCTF _“ciscn_2019_n_1”_（逻辑漏洞+栈溢出） – **任务：**分析给定的C源码或反编译结果（这题通常提供源码），找到通过栈溢出改变程序流程的办法。 – **提示：**程序要求某变量等于特定值才会调用`system("cat /flag")`；而该变量未正确初始化，可利用溢出覆盖之。 – **执行：**计算需要覆盖的偏移，将目标值写入相应内存偏移，触发条件执行`system`拿下flag。|_关键点：_ 理解除经典“覆盖返回地址”外，**修改局部变量**也能影响程序逻辑。例如本题利用栈溢出改变变量`v2`的值使其满足条件。 *方法：*找出变量在栈中的位置（可通过变量相对于栈底的偏移，IDA伪代码里标注如`[rbp-8]`），然后构造输入使该偏移处的值变为要求值（如11.28125的浮点表示）。 *调试：*用GDB逐步运行程序，验证溢出前后关键变量的值是否如预期改变。|WP参考：（讲解逻辑绕过思路）栈变量覆盖实例讲解：参考某博客 _“变量覆盖绕过验证”_ 章节|
|**3**|**练习题：**BUUCTF _“pwn1_sctf_2016”_（32位Ret2text） – **任务：**溢出32位程序栈，直接跳转到.text段中的shellcode或已存在的`system`调用。 – **分析：**检查程序保护：32位、NX关闭意味着可在栈上执行shellcode；或者程序可能内置`/bin/sh`字符串和`system`函数引用。 – **方案：**如果有已存在函数，直接覆写返回地址；如果需注入shellcode，则将“\x90...shellcode”写入缓冲区，并让返回地址指向缓冲区起始。 – **实践：**用MSFvenom生成简单shellcode（或直接使用比赛给出的hint），利用padding + shellcode地址完成漏洞利用。|_关键点：_ 熟悉32位下调用`system("/bin/sh")`的栈参数传递顺序：在payload中需先压入返回地址的占位，然后是`system`地址，然后填一个假的返回地址，再压入`"/bin/sh"`地址。 *Shellcode注入：*了解NOP滑板和shellcode作用。如果选择shellcode方式，需注意避免字符串中出现空字节截断。 *验证：*在本地关闭ASLR（执行`echo 0 > /proc/sys/kernel/randomize_va_space`）后，用GDB测试payload是否成功获取shell。|题解参考：（32位ROP参数排列解释）MSFvenom教程：“快速生成shellcode指南”|
|**4**|**主题学习：Ret2libc** – **概念讲解：**Ret2libc利用流程分解：1) 泄露libc中函数地址；2) 计算基址并构造`system("/bin/sh")`调用。 – **示例演练：**使用提供的练习程序（如`ret2libc_demo`，内部调用`puts`输出`puts`函数在GOT表地址），通过格式化字符串或溢出返回地址到`puts@plt`输出`libc`地址，然后跳转`main`循环。根据泄露地址计算libc基址，再构造二次攻击payload：返回地址指向`system`，后跟`exit`地址和`"/bin/sh"`地址。 – **脚本编写：**用Pwntools编写完整EXP：先收集泄露信息，再发送二次payload获取shell。|_关键点：_ 掌握Ret2libc“两步走”思想：第一次利用printf/puts泄露→第二次利用真实地址攻击。 *细节：*64位下调用`system`需设置好RDI=`/bin/sh`地址，可以通过找`pop rdi; ret` gadget实现（Pwntools的ROP模块可自动搜索gadgets）。 *工具：*使用`Pwntools.ELF`加载binary和libc，方便获取符号地址和计算偏移。练习使用`libc.search(b"/bin/sh")`寻找字符串地址，或直接用`next(libc.search(b"/bin/sh"))`。 *验证：*成功拿到shell后，在交互模式输入`whoami`等验证。|Ret2libc教程：（64位pop寄存器及/bin/sh参数设置）实例EXP参考：（泄露libc及double payload示例）|
|**5**|**练习题：**BUUCTF _“bjdctf_2020_babystack”_（启用Canary的栈溢出） – **任务：**应对存在Stack Canary的64位栈溢出题。程序大致逻辑：读取输入到栈缓冲区，有Canary和NX保护，需要泄露Canary值再二次利用。 – **步骤：**1) 利用格式化字符串或信息泄露漏洞泄露栈中Canary值；2) 溢出时在payload中填入正确的Canary，再覆盖返回地址为`system("/bin/sh")`的ROP链。 – **调试：**使用GDB配合`vmmap`查看stack段，确认Canary位置；尝试输入超长字符串观察程序输出（某些题会在崩溃信息泄露Canary）。如果无直接泄露，则考虑利用`printf`漏洞打印栈值。 – **完成：**构造最终payload：`padding + canary + 填充对齐 + ROP链(pop rdi;ret; "/bin/sh"; system)`，运行拿shell。|_关键点：_ Canary机制防止栈破坏：在函数返回前检查Canary值是否被改动，若不匹配则异常终止。因此利用栈溢出时必须保持Canary值正确。 *泄露技巧：*某些题目提供输出漏洞可直接打印栈内容得到Canary（如格式化字符串`%llx`遍历栈）；若无，考虑布尔泄露（逐字节暴力猜，也可借助脚本）。 *ROP链：*在有Canary的情况下，payload布局：溢出缓冲→旧Canary→旧RBP→新返回地址。切记Canary占8字节且必须原值填回。 *脚本：*用Pwntools自动泄露：例如循环尝试每个字节0x00-0xff拼出Canary，或利用`recvuntil`截取已泄露信息。|Canary绕过思路参考：（提到Canary在CTF中的作用）WP参考：CSDN博客 _“babystack题解”_（包含泄露Canary及ROP构造）|
|**6**|**练习题：**BUUCTF _“jarvisoj_level2_x64”_（64位ROP综合） – **任务：**64位ELF开启Partial RELRO和NX，考察ROP链构造。需要调用`system("/bin/sh")`，程序中可能没有直接/bin/sh字符串，需要从libc寻找。 – **分析：**用`checksec`确认保护，用IDA找出可泄露信息的函数（如puts@plt调用）。 – **步骤：**第一阶段调用`puts`输出`puts@GOT`得到libc基址，返回主函数；第二阶段构造ROP：用`pop rdi;ret`装载`/bin/sh`地址，再调用`system`。 – **实现：**使用Pwntools ROP模块辅助寻找gadgets和符号地址，编写EXP完成两阶段攻击。|_关键点：_ Partial RELRO表示GOT表可写，但此题不一定需要改GOT。No PIE程序基址固定，可直接使用.got/.plt地址。 *Libc版本：*知道精确libc版本才能算偏移，否则需用已泄露符号地址在libc库列表中匹配版本（如用libc数据库脚本）。 _实践:_ 利用`ROP`库自动生成ROP链: `rop = ROP(elf); rop.call('puts', [elf.got['puts']]); rop.call('main');` 快速创建泄露序列。拿到地址算出libc_base后，再次`rop = ROP(libc)`构造`system(binsh)`调用。 *调试：*在本地用对应libc.so测试EXP，确保payload长度和结构正确。|Writeup参考：（利用puts泄露libc的步骤）Pwntools ROP用法: 官方文档“Using ROP with Pwntools”|
|**7**|**每周回顾：** – 列举Week2涉及的利用技巧：如函数跳转、双阶段Ret2libc、Canary泄露绕过、ROP链。在笔记中分别总结它们的利用模板和注意事项。 – 整理已掌握的ROP gadgets：常用如`pop rdi; ret`、`pop rsi; pop r15; ret`等在64位中的作用，并记录如何快速寻找（ROPgadget工具/Pwndbg `rop`命令）。 – 回看本周题目的Writeup，对比自己的解法，找出可以改进之处（例如是否有更简洁的ROP链、利用更稳健的方法）。 – **额外预习：**了解格式化字符串漏洞的基本原理（为下周做准备）：printf的%n写任意地址、%s读任意地址等。|_关键点：_ 通过分类总结，形成对各类栈漏洞的清晰认知：**直接跳转型**（call已有函数）、**返回libc型**（需要泄露libc）、**ROP链型**（需要拼gadgets）。 _精进：_ 思考如何更通用地编写EXP，例如结合前几题编写一个通用的“泄露libc并自动计算偏移”脚本模块。 _查漏：_ 若本周有未完成题目或概念不清，利用这天时间集中攻克，请教AI或学长解决疑难。 _准备：_ 下周将重点学习格式字符串和逆向，提前回顾C语言中printf用法和内存表示，为理解格式化漏洞做铺垫。|经验分享：（不用和用工具两种方法练习，有助熟悉过程）CTF Format String漏洞综述：参考文章《格式化字符串漏洞原理与利用》|
## **Week 3：综合ROP与保护绕过**
| **Day** | **任务及练习题**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | **关键点**                                                                                                                                                                                                                                                                                                                       | **参考资料**                                                              |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| **1**   | **专题研习：漏洞保护机制绕过** – **学习内容：**详细了解四大保护机制：Canary、NX、ASLR、PIE、RELRO，各自防御作用和绕过思路。 – **实验演示：**编译两个小程序分别演示Canary与NX：开启Canary的程序溢出会被检测终止；开启NX的程序放入shellcode将执行失败。通过这些实验直观理解保护效果。 – **绕过思路：**总结前两周已有案例：Canary可通过信息泄露获知再填回；NX通过Ret2libc/ROP绕过；ASLR通过泄露模块基址对抗；PIE增加地址不确定性，需要先泄露主模块地址。 – **工具**：学会使用`checksec`命令或pwndbg的`checksec`功能快速查看目标程序开启了哪些保护。                                                                                                                                                                                                                  | _关键点：_ “知己知彼”，理解每种保护的意图和实现。例如：Canary在栈返回地址前放哨兵值；NX标记栈不可执行迫使攻击者利用已有代码；ASLR随机化地址增加破解难度；RELRO强化GOT不可修改。 *思考：*对于同时启用多种保护的题，需要组合手段：如启用NX+Canary，则先泄露Canary再ROP；启用PIE则要先泄露基址计算偏移。 *总结：*列出各种保护的**绕过流程**，为后续解题提供框架。例如：“存在Canary→先泄露Canary；存在NX→改用Ret2libc；存在PIE→找信息泄露获取基址”。                                                           | 参考文档：《GNU/Linux x64 缓解措施 bypass 方法论》CTF-Wiki相应章节：（PWN保护机制概述）          |
| **2**   | **练习题：**Bugku _“pwn3”_（开启Canary/PIE的栈溢出） – **任务：**综合利用信息泄露和栈溢出绕过保护获取shell。本题环境：64位，**Canary保护**开启、**PIE开启**、部分RELRO。 – **步骤：**1）泄露Canary：题目提示在崩溃信息或可通过格式化字符串输出栈值获取Canary。2）泄露PIE基址：可以利用格式化字符串打印程序地址或泄露某全局变量地址进而推算基址。3）利用泄露信息构造ROP链：填入正确Canary，使用基址计算出`system`等函数地址，完成Ret2libc攻击。 – **工具：**使用`Pwntools`的`fmtstr_payload`或手动构造格式化字符串读取需要的内存地址值。用GDB附加远程进程（如题目提供调试权限）观察内存布局，辅助泄露。                                                                                                                                                                             | _关键点：_ 格式化字符串作为强大信息泄露工具：`printf("%15$p")`可取出第15个栈元素的指针值，常用于泄露返回地址或Canary。 *Canary泄露：*Bugku pwn3的WP中通常先通过程序的第一次溢出机会泄露出Canary值，然后在第二次利用时填入。 *PIE基址：*可通过printf泄露任意全局函数地址（如puts@got），用泄露值减去偏移得出模块基址。 *EXP实现：*调用`fmtstr_payload(offset, {addr: value})`自动生成payload改写内存，或使用`ROP`连续调用puts泄露多个地址。分阶段调试，每次确保泄露数据正确无误。                  | WP参考：（讲解leak Canary和libc基址的思路）格式化字符串利用参考：（任意地址读写的printf原理）            |
| **3**   | **练习题：**BUUCTF _“get_started_3dsctf_2016”_（ROP + Shellcode执行） – **任务：**该题要求利用ROP调用`mprotect`等系统调用，使栈可执行并运行自定义shellcode。考察**Syscall**及ROP综合运用。 – **思路：**程序可能不包含`system`或`/bin/sh`字符串，因此直接Ret2libc不可行。需要：1）利用ROP调用`mprotect`将栈页权限改为可执行；2）将shellcode写入栈（可直接在payload附加）；3）再ROP跳转到栈执行shellcode。 – **实现：**寻找`mprotect`函数plt地址和合适的参数（起始地址向下对齐，例如0x40000000，长度0x1000，权限0x7）。ROP链包含：`pop rdi;ret`加载起始地址，`pop rsi;ret`加载长度，`pop rdx;ret`加载权限值，然后调用`mprotect`。之后紧接一个栈地址（shellcode位置）的跳转。 – **执行：**准备好64位`shellcode`（如调用`execve("/bin/sh")`），填在payload末尾。运行EXP获取shell。 | _关键点：_ 学习调用**系统调用**的两种方式：调用libc函数（如`mprotect`）或者直接使用`syscall`指令加适当寄存器值。此题选择前者简单。 *ROP链构造：*可能需要**Sigreturn**技术：构造伪造的`sigcontext`在栈上，利用`syscall`指令的特定寄存器值触发返回（属于SROP）。如果常规ROP足够则不需要SROP。 *Shellcode：*练习编写或使用现成shellcode（注意64位syscall调用序列与32位不同）。 *调试：*分段测试：先验证mprotect是否成功（可在shellcode开头插入触发某输出的指令用于判断执行到此），再调试shellcode执行是否跳入。 | 参考Writeup：（PWN高级考点提及）“mprotect ROP”技巧参考：（通过更改内存权限执行shellcode的思路提及）    |
| **4**   | **选学题 (SROP 技术)：** _“HNCTF_2022_ret2shellcode”_ 或同类题 – **任务：**体会Sigreturn Oriented Programming。一般过程：溢出触发`syscall`进入`sigreturn`，由内核从栈上恢复寄存器，从而一次性设置多个寄存器值，实现系统调用。 – **分析：**这种题目提供`syscall; ret`指令，可借此进入sigreturn。攻击者需构造栈上的`sigcontext`结构，其中指定RAX=0x3b(execve系统调用号)、RDI指向`/bin/sh`、RSI=0、RDX=0等，然后当`syscall`执行时，内核将寄存器加载这些值并再次执行`syscall` = execve。 – **步骤：**1）构造触发sigreturn的ROP链（通常只需将RAX设为0xf, 调用`syscall`即触发sigreturn）。2）准备sigcontext frame（Pwntools提供`SigreturnFrame`辅助）。3）将frame附在payload后并执行。成功后直接获得shell。                                             | _关键点：_ SROP利用一次性调用内核恢复寄存器，避免繁琐多步ROP，关键是正确构造frame。 *SigreturnFrame：*使用`frame = SigreturnFrame(arch='amd64')`，然后设置`frame.rax=0x3b; frame.rdi=binsh_addr; frame.rip=syscall_addr;`等，将frame数据填入payload。 *注意：*需要找到程序中可用的`syscall; ret`序列地址。 *收获：*掌握SROP虽非必须，但了解其思路有助于攻克某些限制多的题。可将其作为进阶技能储备。                                        | SROP教程：参考博文《x64 SROP 原理与实例》SigreturnFrame用法：（可能需自行搜索SigreturnFrame案例） |
| **5**   | **练习题：**360比赛 _“babyrop (OGeek2019)”_（32位 Full RELRO 提示） – **任务：**在Full RELRO情况下无法修改GOT，考察其他利用思路。该32位程序或需返回到栈上的shellcode执行。 – **分析：**Full RELRO表示GOT表完全只读，传统覆写exit@got跳转system的方式不可行。因此如果题目未给后门函数，则常用方案是使用栈pivot+shellcode或SROP。 – **方案：**检查程序是否提供读写任意地址的漏洞（如栈迁移gadgets）。若有，可将ESP指向输入缓冲区，再将shellcode写入并跳转执行。 – **实现：**找到`leave; ret`指令用于栈迁移（将EBP设为我们可控区域地址），payload第一阶段把新栈地址写入EBP，然后第二阶段执行shellcode。 – **验证：**因为32位无Canary（假设），可本地调试shellcode运行效果，再远程利用。                                                                                                   | _关键点：_ **栈迁移**技术：利用`leave; ret`实现ESP切换到更大的可控缓冲区。此技术在构造较大ROP链或shellcode时有用。 _Full RELRO下ROP:_ 仍可Ret2libc，但需通过泄露获取libc后，不能改GOT，只能直接调用libc中函数。如果程序没有后续输入机会，则shellcode法更直接。 _Shellcode注入:_ 注意32位shellcode长度一般较短，可以手写或用MSFvenom。No NX时直接跳即可。 _收获:_ 强化对不同保护的应对策略，锻炼灵活调整利用方案的能力。                                                     | 栈迁移讲解：（leave指令如何劫持ESP）WP参考：OGeek2019官方解题报告                            |
| **6**   | **限时实战练习①：** 从BUUCTF或往年比赛中选取一题中等难度PWN题，计时尝试独立完成。 – 建议题目：_“ciscn_2019_en_2”_ 或 _“ZJCTF2019_login”_ 等涉及多步骤利用的题。 – **要求：**严格计时8小时以内完成从分析到拿flag的全过程。如中途卡壳超过2小时，可查阅资料或WP，但记录下卡住的原因。 – **过程：**像比赛一样分析程序逻辑、确定漏洞类型，迅速决定利用方案并编码调试EXP。尽量少依赖调试工具GUI，多用gdb+脚本配合，提升效率。 – **赛后复盘：**比较自己的解题思路与官方WP，总结时间花在哪些步骤，哪些知识不熟练导致延误。在笔记中写下改进计划。                                                                                                                                                                                                                                     | _关键点：_ 通过模拟比赛，发现自己在实战中的**短板**。可能暴露的问题：如分析二进制逻辑耗时长、ROP链构造不熟练、调试方法笨拙等。 _策略：_ 练习合理分配解题时间：基础检查(10-15分钟 checksec/IDA快速浏览)、漏洞验证(30-60分钟编写PoC)、编写EXP(1-2小时)、调试修改(<2小时)。 _心态：_ 训练抗压能力，在模拟中适应计时和flag驱动的紧迫感，锻炼遇到挫折时调整思路、果断取舍（如放弃卡住思路转尝试别的方法）的决策力。 _积累：_ 将本次实战中新学到的trick补充进笔记，如意外遇到的格式化字符串用法、某保护的特殊绕过等。                                  | 竞赛经验参考：（提到赛中查资料和赛后看wp的机制）某比赛WP集合：参考公开WP（综合题解思路，可对照学习）                 |
| **7**   | **每周小结：** – 针对本周高强度练习，整理一份**“PWN中级技能清单”**：包括常见信息泄露方法（Printf泄露、泄露GOT等）、ROP常用gadgets、堆利用基本流程等。 – 将之前笔记中零散的知识进行系统化，例如制作一个思维导图涵盖“溢出->泄露->利用”的各分支情况。 – 回顾限时练习的教训，重点复习那些不熟练的知识模块。必要时，可再找一道类似题目非限时地重新做一遍，加深印象。 – 本周是冲刺过半，注意检查自己的身体和心理状态，保证接下来学习效率。适当调整作息，避免疲劳积累。                                                                                                                                                                                                                                                                                                  | _关键点：_ 梳理所学形成**体系化知识网络**，而不仅是零散题目的解法。例如将所有格式化字符串的用途、ROP链构造步骤、heap利用套路各自归纳成流程图。 _查缺补漏：_ 若发现对某主题理解仍薄弱（如还是不会SROP或某类题每次都卡住），考虑在接下来时间针对性加强：可以向队友或社区请教经验。 _调整：_ 长时间高强度学习需防止倦怠，复盘日尽量放松心情，可适当减少当天任务量以恢复精力。 _展望：_ 下周将转入格式字符串和逆向及Web的学习，这是不同于溢出的新领域，提前做好心态准备，迎接新的挑战。                                                                    | PWN知识结构示例：知乎文章《如何系统化学习PWN》学习方法建议：（PWN学习从易到难的经验谈）                      |
## **Week 4：格式化字符串漏洞 & 逆向入门**
| **Day** | **任务及练习题**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | **关键点**                                                                                                                                                                                                                                                                                                                                                                                                                  | **参考资料**                                                                                    |
| ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------- |
| **1**   | **专题学习：格式化字符串漏洞** – **原理学习：**了解printf系列函数格式化字符串的工作原理。当用户可控字符串作为格式化参数时，`%x`、`%s`、`%n`等格式符可用于读写内存。尤其`%n`会将已输出字符数写入指定地址，可实现任意地址写；`%s`能输出给定地址处的字符串，实现任意地址读。 – **案例讲解：**阅读CTF Wiki或书本中经典案例：如何通过`printf("%7$x")`泄露栈中返回地址或Libc地址，通过`printf("%n")`配合精心构造参数写入内存。理解**偏移**的概念：printf内部按栈获取参数，所以需要调整占位符定位目标地址。 – **安全机制：**了解现代编译器对格式化字符串漏洞的防护（例如`%-.*s`限制等）但CTF题多为自造简化环境，无格式保护。 – **简单练习：**编写一个小程序演示`printf`漏洞：使用`printf(user_input)`，传入`AAAA %x %x %x`观察输出，以及尝试`%s`打印任意地址（用GDB设定一个地址尝试）。                                                                | _关键点：_ printf按照堆栈参数输出，当格式字符串本身可控时，攻击者可以“骗过”printf访问任意地址的内容或写任意地址。 *偏移计算：*通常需要找到格式串位于栈的位置。例如`printf("%7$x")`中的7说明取第7个参数。如果想打印某地址的内容，需要让该地址出现在printf参数里（可将地址写进输入并在格式串用%s引用它）。 *任意写：*利用%n时，printf会把已经输出的字符数写到指定地址。攻击者通过精确控制输出长度，实现写入特定值。需用到格式宽度控制，如`%8c`打印8个字符，结合%n多次写入拼成目标值。 *风险：*不正确使用%n易导致程序崩溃，要确保写入地址有效可写。 *总结：*格式化字符串漏洞本质是**格式字符串内容可控**导致的读写任意地址能力，是CTF常考漏洞类型之一。                                                       | CTF Wiki：（printf任意读写简述）漏洞原理详解：（对任意地址读写的解释）                                                  |
| **2**   | **练习题：**第五空间2019决赛 _“PWN5”_（格式化字符串漏洞） – **任务：**利用格式化字符串同时实现**信息泄露**和**控制写**，最终劫持程序流程。此题综合考察格式化字符串漏洞能力。 – **分析：**根据WP，本题包含一个`printf(user_input)`，可泄露随机数或Canary等关键数据。且可用%n修改内存，如修改登录验证变量或返回地址。 – **步骤：**1）用`%x`/`%s`系列payload泄露需要的信息（例如libc地址或flag存放地址）；2）设计%n写入：将目标地址放入输入（比如开头放入目标地址的值），然后在格式串部分使用适当位置的%n，把已输出字符数写到该目标地址。需要分多次写入时，使用多个%n和适当的宽度控制。 – **实现：**手工构造payload难度较高，可借助`Pwntools`的`fmtstr_payload`函数自动生成payload。传入已知偏移和期望写入的{地址:值}字典，可得到可用payload。 – **执行：**运行EXP，将payload发送给服务，实现内存改写，预期触发程序执行`system("/bin/sh")`或直接篡改返回地址跳转getshell。 | _关键点：_ **同时利用读写：**先读（泄露）再写。在一轮printf调用中也可以先输出一些值（泄露），再在同一个字符串里使用%n写。要确保顺序合适，不要提早触发崩溃。 *偏移确定：*使用`%p`打印一系列指针值，找到输入中的已知模式（如AAAAAAAA对应0x41414141），推算出我们的格式串在第几个参数。 *多字节写：*由于%n一次只能写入4字节整形，写一个8字节地址的值需要两次%n操作。利用格式宽度（如`%123c`）凑字节数，然后%n写低位，再构造下一个%n写高位。打印顺序和地址顺序需要精心安排。 *工具：*推荐用pwntools的`FmtStr`工具自动寻找偏移并执行写入。让脚本尝试不同offset直到成功写入测试地址，获得精确偏移。然后用`fmtstr_payload`生成最终payload。 *验证：*在本地用相同二进制调试，看被改写地址是否成功变为预期值，flag获取逻辑是否被触发。 | WP参考：（说明了使用%n写入随机数等）格式化字符串利用案例: 安全客文章《CTF格式化字符串漏洞解题技巧》                                      |
| **3**   | **练习题：**BUUCTF _“axb_2019_fmt32”_（32位格式化字符串） – **任务：**32位程序存在格式化字符串漏洞，可能需泄露libc并修改GOT表函数指针跳转shell。 – **分析：**32位地址相对较短，格式化攻击中常用写GOT表某项为`system`地址。例如将`printf@GOT`改为`system`，下次调用printf时实际执行system，实现shell。提示了这一思路：先泄露libc基址，再用%n改GOT。 – **步骤：**1）用`%s`读出程序输出的某个地址内容，获取libc地址。2）计算`system`地址。3）利用%n分次将`printf@GOT`地址改写成`system`地址低2字节、高2字节（32位可两次写完）。 – **实现：**payload设计：前半部分放`printf_got`地址的低2字节、高2字节（两次%n需要两个地址），然后格式串部分输出适当字符数后来完成写入。使用pwntools的`FmtStr`也可。 – **运行：**本地调试观察GOT表变化，成功后远程运行EXP拿shell。                                         | _关键点：_ **修改GOT表**是经典利用：比如把`exit@GOT`或`printf@GOT`改成`system`地址，这样当程序调用这些函数时，其实调用的是system。此方法要求目标函数在后续流程会被调用一次。 _对齐输出:_ 使用%n写具体值要考虑之前已经打印的字符数，可利用`%(value)x`直接打印value个字符，再%n写0，从而将value写入目标地址。但printf限制输出长度，要结合多个%n分段写。 _32位注意:_ 32位写入可能需要考虑字节序，每次%n写入2字节（因为printf参数为int），所以可两次完成对4字节地址的覆盖。提到partial write策略，可参考。 _检查:_ 写入后用`readelf -r`或GDB观察GOT表验证是否修改成功，然后继续执行程序看是否跳转执行了`system("/bin/sh")`。                            | 思路参考：（利用格式化字符串泄露libc和修改free_hook的思路，可类比用于GOT）GitHub示例: libc-database repository（练习泄露计算libc） |
| **4**   | **实践：利用脚本自动生成格式化payload** – **任务：**将Day2或Day3的格式化字符串利用用Pwntools自动化。 – **步骤：**1）使用`fmt = FmtStr(exec_func, offset=?)`尝试自动探测offset（exec_func可用类似函数来触发printf）。或者使用`FmtStr`类的write方法直接写。 – **2）**使用`fmtstr_payload(offset, {addr1:val1, addr2:val2})`生成payload，比较与自己手工构造的区别。 – **3）**完善EXP：包括前期泄露的自动化（用`recvuntil`等截取泄露值计算libc_base）和后期写入的payload发送。 – **调试：**注意不同libc版本下偏移可能不同，确保使用正确libc或者将exploit设计为从远程泄露中自适应。 – **结果：**成功用一键脚本拿下flag，巩固格式化字符串漏洞的利用技能。                                                                                        | _关键点：_ 善用**自动化工具**提高效率。例如pwntools的`fmtstr_payload`能自动拆分字节写入序列，大幅减少人为计算错误。 _验证正确性:_ 打印或断点观察payload中格式串部分是否符合预期（例如含有%hn等指令及正确的padding数）。 _稳健性:_ 考虑payload中可能出现`\x00`截断问题，尽量避免或者改用`sendline()`区别处理。 _能力提升:_ 通过手工和自动两种方式对比，理解自动化工具背后的逻辑，也提升对格式化漏洞各种边角情况的处理能力（如输出长度超过预期，%hhn/%hn区别等）。                                                                                                                                         | FmtStr用法参考：（文中演示了fmtstr_payload的效果）Pwntools官方文档：“Working with Format Strings in Pwntools”   |
| **5**   | **逆向练习1：BUUCTF Easy Reverse** _“easyre”_ – **任务：**下载提供的简单可执行文件（可能是64位PE或ELF），使用IDA/Ghidra打开，找出flag或密码。 – **分析：**1）先检查字符串：利用IDA的Strings窗口搜索可疑字符串“flag”或明显的Base64编码、hex串等。许多入门逆向题flag往往明文或简单加密存储在可执行文件里。 – **2）**若字符串未直接出现，则看看`main`函数逻辑：可能要求输入一个密码，然后在代码里有比对操作。找到比对函数，把正确密码（或加密算法还原）提取出来。 – **工具：**掌握IDA基本操作：按F5查看伪代码、命名关键变量、使用调试运行程序（如果需要动态验证猜想）。 – **结果：**通常easyre题Flag获取不会复杂，可能就是文件里存着，或轻微编码。将解出的flag提交验证成功。                                                                                                                               | _关键点：_ **静态分析思维：**先粗略看程序结构，抓住要点（哪里产生输出、哪里读取输入与比较）。 *技巧：*学会识别简单加密/编码：如看到大量`xor`操作，多半是异或加密；看到Base64字符集则是Base64编码。可将相关代码段复制出来写脚本解码。 *实用工具：*尝试使用在线工具或Python库辅助（如base64解码），但在赛中有时只能手动，这里可以练习迅速识别和处理。 *总结：*逆向题的关键在于**耐心**和**细心**，一步步推导程序逻辑，记录每个关键分支条件，最终还原出隐藏信息。easy难度主要考查使用IDA等工具找信息的基本功。                                                                                                                                     | 参考资料：（easyre题Writeup思路）逆向基础讲解：（逆向工具IDAPro的典型用途）                                             |
| **6**   | **逆向练习2：BUUCTF Reverse** _“reverse1”_（简单加密算法） – **任务：**分析一个含简单算法的逆向题，通常程序会提示输入密码或执行某算法。通过逆向获取正确输入或解密数据。 – **分析：**阅读伪代码/汇编，找出核心算法，比如一段循环对输入每个字符异或固定值，或把输入通过某数学运算和常量比较。将算法逻辑翻译成高层语言理解。 – **步骤：**1）提取关键代码，将其改写为Python脚本以便测试。2）若是密码验证，则直接在脚本中逆推得到正确密码；若是解密Flag，则模拟算法算出Flag。 – **实践：**例如发现程序要求输入长度N，每个字符满足`((char ^ 0x3)*7) mod 26 = X`，这种可逐字母推解。或者程序将固有密文经过异或、倒序等得到明文Flag，则编写脚本反向处理。 – **验证：**运行脚本拿到结果，在原程序中输入验证，或Flag直接由脚本算出。                                                                                                                   | _关键点：_ **读懂简单算法：**训练从汇编或伪码提炼逻辑公式的能力。针对常见模式：异或、移位、取模等，要能识别出来。如看到`ROL`/`ROR`是循环移位，`xor`则异或，加减直接看字面。 *动静结合：*若纯静态难理解，可以运行程序，尝试用试探法：输入一个简单字符串看输出如何变化，从而猜测算法。例如输入AAAA看到输出模式推断出每位处理方式。 *借助自动化：*学会使用调试器设置断点观察内存变化，或者直接Dump内存中可疑数据段。有的题Flag直接放内存，逆向只需找到并dump即可。 *总结：*通过这题，掌握逆向CTF题常见套路：自制简单加密（异或、移位、换位等），要多练几类就能快速认出。逆向代码后写脚本验证也是比赛常用技巧。                                                                                          | 题解参考：（说明分析代码找出flag的过程）汇编识别指南：《常见简单加密汇编模式辨识》                                                 |
| **7**   | **本周总结 & 适应调整：** – 回顾格式化字符串漏洞的利用模式，将其与栈溢出、堆漏洞进行比较，理解各类漏洞异同（例如格式化字符串不需要可执行注入，但可直接读写内存，利用步骤不同）。 – 整理逆向部分：总结常见逆向题类型（字符串硬编码、简单运算校验、加密编码等），记录对应的解法套路（如看字符串->追关键函数->还原算法）。 – 评估目前Web知识进展，如还未涉及Web，本周可稍花时间了解1-2个简单Web漏洞（比如SQL注入或文件包含)，为下周深入做准备。 – 根据自身状态调整后续计划：如果PWN方向感觉吃力，可适当削减下周Web/RE时间继续攻PWN弱项；反之PWN已较稳，则按计划继续拓宽Web领域学习。                                                                                                                                                                                                                        | _关键点：_ 将**格式化字符串**升华为通用技巧：比如在PWN题中，哪怕不是printf漏洞，有时也可用格式串原理手工leak信息（如scanf的`%s`不安全用法）。扩大思维，不局限于题目本身。 _逆向技能_: 经过两题练习，应总结出一套解逆向题的**流程**：先静态扫字符串->动态验证猜想->编写脚本批量运算，等等，形成固定方法以应对不同题目。 _Web预热：_ 可尝试通过CTFshow等平台做一道基础SQL注入题，体会Web题解题模式（比如输入`' or 1=1--`绕过登录），将思路记录，作为日后参考。 _计划调整：_ 本阶段过后仅剩约4周，需确保PWN主攻目标基本达成。如果对中等PWN还无把握，可考虑缩减Web/RE内容，将更多时间给PWN。灵活调整，以达成主要目标为首。                                                               | 学习方法指导：（鼓励先跟做再独立尝试的过程）Web基础建议：（强调掌握PHP和编程对Web安全的重要性）                                        |
## **Week 5：堆漏洞基础**
|**Day**|**任务及练习题**|**关键点**|**参考资料**|
|---|---|---|---|
|**1**|**专题学习：glibc堆管理与漏洞类型** – **知识学习：**阅读CTF-Wiki堆基础章节，了解glibc中heap运作：`malloc`分配、`free`释放、`bins`链表管理（fastbin, unsorted bin, tcache等）。 – **漏洞综述：**常见堆漏洞分类：Use-After-Free（UAF）、Double Free、Heap Overflow、Off-by-one等。分别理解其危害：UAF可导致悬挂指针被重利用、Double Free导致同一指针进入free链两次、Heap Overflow可破坏相邻chunk元数据。 – **技巧预习：**学习经典利用手法：Fastbin Dup（利用double free将任意地址加入free链）、Unsorted Bin Attack（修改fd指针劫持`__malloc_hook`）等。 – **实验：**运行how2heap提供的简单示例代码，例如演示first-fit分配、fastbin double free等，在gdb中跟踪堆链表变化，加深理解。|_关键点：_ 堆分配通过维护链表，高效但存漏洞隐患：了解fastbin单向链表在释放时LIFO特性，以及tcache(2.26+)缓存机制。 _Use-After-Free:_ 释放后指针悬挂，可通过再次分配获取同一内存，并在旧指针未置NULL情况下进行非法操作。利用UAF可实现在释放后修改数据结构。 _Double Free:_ 一个指针free两次，会将同一chunk多次加入链表，从而破坏链表结构或造成任意地址分配。 _利用思路:_ fastbin attack: 通过overflow修改chunk的fd指针，使malloc返回指向任意地址的指针，实现任意地址写；tcache poisoning: double free后控制tcache bin list，使下一次malloc返回我们指定的地址，然后写入数据达到劫持。 _调试:_ 学习使用glibc调试函数`malloc_stats`或pwndbg的heap可视化命令，观察漏洞利用前后heap结构变化。|glibc堆原理：（first-fit算法示例）how2heap指引：（how2heap教程说明）|
|**2**|**练习题：**NSSCTF _“simple_uaf”_ 或 _“note_uaf”_（Use-After-Free 漏洞） – **任务：**理解并利用UAF漏洞获取flag。此类题通常是一个简易的菜单驱动程序（新增记录、删除记录、打印等）。删除操作未将指针设NULL导致UAF。 – **分析：**利用流程：1）申请一个对象A，释放之；2）再申请一个对象B，由于A已释放，B可能复用A的位置；3）通过旧指针修改A（其实是B）内容，造成任意修改。 – **利用：**具体来说，如果对象结构里有函数指针或敏感数据，通过UAF可改写成我们想要的值（如函数指针改为system地址）。在CTF题中，常见方法是UAF修改`free_hook`或其它关键结构指针。 – **操作：**用Pwntools脚本与程序交互：执行菜单选项alloc/free/alloc，再利用旧索引编辑数据。观察是否可以将伪造数据写入被复用的chunk。 – **目标：**比如本题可能有隐藏命令触发shell，需要将某对象的字段改为特定值（例如输入`sh`字符串存入悬挂的chunk然后执行system）。完成利用，拿到shell或flag。|_关键点：_ UAF的要害在于悬挂指针：释放后未清NULL，所以程序仍可通过老指针访问释放内存。 *利用前提：*新的malloc若返回相同地址，则旧指针就指向新对象。通过旧指针写即修改新对象。 _典型利用:_ 中演示：添加note0->free note0->再add note1->编辑note1内容，利用旧指针note0指向的位置（现为note1）写payload。常用payload是在对象中伪造函数地址或shell命令串。 _防范:_ 实际安全编程中应将指针置NULL，这里理解漏洞成因助于利用。 _确认:_ 用GDB调试，watch住目标地址，验证UAF写确实起作用。|WP示例：（UAF流程与payload示例）漏洞解析：参考博客《Use-After-Free漏洞的利用》|
|**3**|**练习题：**BUUCTF _“ciscn_2019_final_3”_（tcache dup 双重释放） – **任务：**这是道堆基础题，考察double free在tcache机制下的利用。 – **分析：**程序提供申请和释放功能，无额外保护。利用思路：double free后，一个chunk地址会出现在tcache bin的链表两次。随后两次malloc将返回相同地址，从而得到两个指针指向同一块内存。这样可以**写一个指针的数据，用另一个指针读**出来或覆盖元数据。 – **步骤：**1）malloc两次、free第一个chunk两次（或free第一个再free第二个根据漏洞点），触发double free漏洞，将同一地址加入tcache链表两次。2）下次malloc两块相同大小内存，会返回同一地址给两次调用。3）现在有两个有效指针指向相同内存，一个写入数据后，通过另一个指针读取就相当于**任意地址读写**（如果数据被解读为地址）。 – **利用：**通常最终目标是利用double free把控制的数据写入特定位置。例如演示了用unsorted bin leak泄露libc后，double free将`__free_hook`加入链表并被分配出来覆盖。 – **实现：**按照WP步骤，利用double free将`__free_hook`的地址伪造进tcache freelist，下次malloc返回`__free_hook`指针，写入`system`地址。然后执行`free("/bin/sh")`触发system(shell)。 – **执行：**编写EXP自动化上述过程，运行拿shell。|_关键点：_ **tcache double free**：glibc2.27+中，tcache单独维护释放列表，双重释放会导致同一chunk地址出现两次，使后续malloc获取重复地址。利用者可以分配一个伪造大小的chunk指针指向目标地址，从而实现任意地址分配。 _泄露libc:_ 一般需要先泄露libc基址，常用unsorted bin的fd指针（指向main_arena）泄露。 _覆盖hook:_ libc中有`__free_hook`/`__malloc_hook`函数指针，可覆盖为`system`或one_gadget地址。当对应函数被调用时即执行我们想要的代码。 _脚本:_ 利用Pwntools方便构造数据包。如使用`p.sendafter("size:", str(size))`等简化交互。利用hexdump观察内存确认指针是否被正确覆盖。 _验证:_ 成功利用表现为调用`free("sh")`后程序给了shell。可以在远程执行`ls`等命令确认shell权限。|参考WP：（unsorted bin 泄露和 tcache double free 过程）相关知识：（总结先泄露libc再用tcache double free改写hook的方法）|
|**4**|**练习题：**BUUCTF _“ciscn_2019_es_1”_（综合堆利用） – **任务：**这题综合考察heap综合技能：需要先通过UAF或heap overflow泄露libc地址，再通过tcache double free劫持`__free_hook`，最后执行shell。 – **分析：**WP思路：程序有电话本类似功能，可添加条目（包含名字和电话），删除条目有UAF，可利用call功能double free某chunk。 – **利用流程：**1）申请3个chunk（A, B, C）。2）填充A和B，释放A把其放入unsorted bin。3）调用show函数UAF泄露A->fd指针（指向main_arena）得到libc基址。4）释放B两次（double free）让B地址进入tcache freelist两次。5）再次申请两个chunk得到同一地址B的两份指针，其中一份覆盖为`__free_hook`地址。6）第三次malloc返回`__free_hook`指针，写入`one_gadget`地址。7）触发free(C)执行one_gadget，弹出shell。 – **实现：**严格按上述步骤编写EXP，注意每步与程序输出同步，用`recvuntil`匹配菜单。每次操作后用log调试确认状态正确（如泄露的libc地址计算对否）。 – **拿下flag：**交互shell成功后，读取flag文件获取Flag。|_关键点：_ 这道题串联了**unsorted bin leak + tcache poison**的完整链路，是堆利用常见套路。 _调试跟进:_ 建议一步步在本地调试验证，如每完成一步，pause程序检查heap数组、tcache内容是否符合预期。 _one_gadget:_ 使用one_gadget获得shell需满足寄存器约束，通常题目环境满足。也可以选择写`system`地址，然后像前述free_hook改system再free("/bin/sh")。 _可靠性:_ 堆利用对输入长度和顺序要求高，要确保每个malloc/free参数正确无误。一处偏差可能导致崩溃或利用失败。可借助ASAN编译的程序辅助理解错误点。 _收获:_ 完成此题标志着已掌握中等复杂度堆利用的全流程。要将此模版牢记，并能应用到类似的新题中。|详细WP：（完整利用过程）One_gadget使用: GitHub **one_gadget** 项目文档|
|**5**|**补充练习或拓展阅读：** – 如Week5题目未做完，优先补齐。若已全部掌握，可选择阅读进阶材料，例如**Safe Linking机制**：glibc 2.32+引入的堆保护。了解safe linking如何在chunk fd存储加密指针，及现有绕过方法。 – 或选择另一道有代表性的堆题练习，如**House of Orange**或**Babyheap (0CTF)**的WP，体会不同版本libc下的堆攻击差异。 – 动手尝试**glibc源码**简单浏览：查找`malloc`和`free`实现，认知内部结构（如`struct malloc_state`）。虽然深究超出当前需要，但对提升理解很有帮助。 – 整理堆利用笔记：列出每种技巧所需条件和效果，例如“双重释放->任意地址malloc”、“UAF->修改已释放对象”等，以便赛前快速复习。|_关键点：_ 扩展见识，跟上新版本缓解技术：Safe Linking利用单独XOR秘钥防止利用fastbin悬挂指针，但已有研究可通过信息泄露拿到秘钥然后继续攻击。了解这些能对抗“万一比赛考新版本glibc题”的情况。 _House技巧:_ 如House of Orange是一种构造fake chunk修改top chunk size进而分配任意大chunk的方法，虽复杂但可一读开阔眼界。 _源码分析:_ 读glibc源码有一定难度，可选择性查看关键片段。对malloc.c中文件，至少看理解fastbin/tcache结构体定义。 _总结提升:_ 经过一周堆题训练，应对堆不再陌生。将堆和栈利用方法对比，在笔记中形成“遇到堆题我该如何下手”的步骤，如：先`checksec`看版本→尝试常规UAF/Overflow→利用bins泄露/劫持。|Safe-Linking介绍：（说明了Safe-Linking对fastbin攻击的影响）House of Orange WP：参考团队博客文章|
|**6**|**限时实战练习②：** 选取一道综合PWN题（可能同时涉及栈+堆或多阶段利用）进行限时攻克。 – 建议题目：比如*“线上Attack任务”*或XCTF系列决赛PWN题，要求利用多种漏洞结合（如格式化串+堆利用）。 – **过程：**同Week3 Day6模拟竞赛做法，在8小时内尽力自主完成。如果遇到此前未掌握的新技巧，记录下来赛后研究，不浪费太多时间。 – **侧重：**这次练习注重检验对**堆利用**的掌握。在计时压力下，能否正确实施比如double free或leak手法。如不成功，也要尝试调试找原因，而非直接看WP。 – **结果：**无论成功与否，都整理出解题思路。若未完成，通过WP学习正确做法，重点理解差距。 – **反思：**赛后总结此次限时解题在堆部分的问题，比如地址计算错误、libc版本搞错等，并想出避免这些错误的方法（如先本地验证小步骤）。|_关键点：_ 将新学的堆利用应用于实战可能是薄弱环节，要通过限时练习巩固。注意**细心**，堆攻击步骤繁多，任何一步错误都可能失败，比赛紧张时更容易遗漏。通过这次练习培养**细节检查**习惯。 _调整策略：_ 如果限时内迟迟未破，可适当改变攻击思路或简化目标（如先只泄露flag而非拿shell）。灵活应对，锻炼比赛中根据情况调整计划的能力。 _心理锻炼：_ 高级PWN题往往需要多次尝试调参，练习在挫折中保持冷静分析，不急躁，分步验证。 _经验积累：_ 又一次模拟赛，经验值up。将两次实战进行对比，看看相比上次是否进步（用时减少、思路更清晰），以此鼓舞信心，查找仍需努力之处。|经验分享：参见某战队博客《某CTF综合Pwn题Writeup》，学习他们的解题思路和时间分配比赛心态调整：（提到准备本地脚本和避免无互联网赛的措施，体现赛前准备的重要性）|
|**7**|**周总结 & 比赛展望：** – 经过5周高强度训练，全面回顾已掌握技能：包括栈、格式串、堆以及简单Web/RE。制作一份**能力矩阵**，标出自己对各类别题的信心指数。如PWN中栈题有把握、中等堆题基本ok、Web略懂一二等。 – 根据矩阵，制定比赛策略草案：例如优先解PWN易中题，把握拿分；Web题如果遇到简单注入或反序列化可尝试，过难则勿纠缠；RE题酌情而定。 – 列出**最后4周重点**：若PWN仍有短板（如某类型题总没练到），接下来要集中突击。若整体良好，则可以更多关注Web/RE补短。 – 调整学习计划：本周后可以稍微降低强度1-2天放松大脑，防止过度疲劳影响后劲。后面Week6-8将进入查漏补缺和实战演练阶段，要以充沛精力迎接。|_关键点：_ **战略规划：**明确比赛时自己的擅长和弱项，合理分配时间。训练目的是在实战中**得高分**，因此要有取舍意识：自己的强项应保证不失分，弱项能捞多少算多少，不可平均用力。 _自我评估：_ 诚实评估自己对各知识掌握程度，不要侥幸。比赛题往往综合度更高，要稳固基础才能应对变化。 _最后冲刺：_ 剩余时间不多，应进入精细化复习和模拟阶段。可以准备一些小抄（各漏洞利用步骤简表、gdb调试命令速查、常用脚本片段），方便赛前浏览记忆。 _心态：_ 看到自己5周来的进步，应感到信心提升。同时认识到CTF题库浩瀚，仍需保持谦逊学习态度，继续努力。调整好心态，以积极但不过度紧张的状态进入最后冲刺。|竞赛策略参考：知乎问答《CTF比赛如何合理分配时间》自我评估表模板：某安全团队培训资料PPT|
## **Week 6：PWN综合提高 & 脚本化练习**
|**Day**|**任务及练习题**|**关键点**|**参考资料**|
|---|---|---|---|
|**1**|**漏洞综合复习日：** – 列出所有学过的漏洞类型：Stack Overflow、Format String、Use-After-Free、Double Free、其他（整数溢出、文件操作等若学过）。对每种漏洞各写一句话总结成因和利用手法，加深记忆。 – 通过历届CTF题目名称检索，加深印象哪些比赛爱考哪些漏洞类型。例如某比赛连续几年都有格式化字符串题，某比赛爱考堆题等。 – 回看以前不太理解的WP，现在以新视角重新阅读，可能会有新的收获。 – 小测验：闭卷手绘一遍Return-to-libc、fastbin attack等步骤流程图，不看笔记能否想全。如果有遗忘，及时弥补。|_关键点：_ 查缺补漏，以防“考试”时遗漏步骤。将复杂利用分解成可背诵的步骤，如Ret2libc：泄露地址->算偏移->构造payload->调试。 _知识融会贯通：_ 思考不同漏洞间的相似之处，如格式化字符串的任意写功能有时可替代堆漏洞达成相同目的（写GOT）；栈溢出与堆溢出都可覆盖函数指针等等。理解这点有助于灵活应变。 _注意遗忘：_ 人对不常用知识遗忘快，如之前学的SROP、safe-linking如果感觉记不清，就快速翻看笔记重温。比赛中若遇到，至少脑中有印象不会完全茫然。 _保持状态：_ 本日可稍微轻松些，以整理为主，把大块时间花在回顾而非新题，以防持续紧绷造成疲劳。|学习金字塔模型参考：将所学转述画图是高效记忆CTF题型分布统计：参考CTFHub比赛统计网站|
|**2**|**PWN脚本能力提升：** – **Aim**: 提高编写Exp效率和鲁棒性。 – **练习：**给之前某道半自动解的题重写一个**模块化EXP**。要求：1) 抽取重复步骤为函数（如send_payload/recv_leak等）；2) 加入错误处理，如如果泄露信息不完整就重试；3) 脚本开头增加参数方便切换本地/远程、调试模式。 – **Pwntools高级用法：**学习`DynELF`自动泄露函数地址、`ROP`类自动找gadgets、`shellcraft`快速生成shellcode等便捷功能，将其中适用的融入EXP编写。 – **验证：**对比改进前后脚本，在相同环境下，新的EXP成功率更高、速度更快，代码结构清晰。 – **收获：**养成**写模板**的习惯，比如预先准备好一个通用EXP框架，在比赛时根据题目快速套用，大幅减少基础编码时间。|_关键点：_ **模块化脚本**：将常用功能做成模板，如`def leak(addr): ...`封装读内存，`def write(addr, val): ...`封装写内存。这样遇到题目直接调用，大大节省时间。 _健壮性:_ 考虑网络不稳定或服务响应慢，脚本加入`timeout`和`retry`机制。比赛中掉线或卡顿时自动重连继续，避免人工干预浪费时间。 _调试模式:_ 在脚本中设计一个`DEBUG`开关，打开时使用`process()`附加gdb调试，关闭时用`remote()`直连服务。这样切换调试/攻击方便又不必改多处代码。 _shellcraft:_ 练习使用pwntools的`shellcraft`生成shellcode，例如`shellcraft.sh()`获取execve("/bin/sh"), 并用`asm()`转机器码插入payload，避免自己写汇编。|模板代码示例：开源项目Pwntools的example脚本高级功能参考：DynELF（利用ctfs库泄露libc符号）|
|**3**|**跨类别实战：综合训练Web/RE** – **任务：**在不影响PWN复习的前提下，选择1道简单Web题和1道简单RE题限时各1小时完成，保持对这些题型的感觉。 – **Web练习：**挑一个基础题，如**SQL Injection**(联合注入) 或 **文件包含**漏洞题。快速回顾注入语法或PHP伪协议用法，争取手工构造payload拿flag。 – **RE练习：**挑一个与Week4不同类型的题，比如简单的 CrackMe（密码硬编码在程序中）或者一道 Android APK 逆向（看资源文件）。用学过的方法速解。 – **目的：**保持多面手意识，虽然主攻PWN，但比赛遇到送分Web/RE不能错过。这些领域基本思路要熟悉，如SQL注入检查`' or 1=1--`，逆向看到可疑字符串要追踪等。 – **结果：**如顺利解出，记录解题过程作为笔记；如未及时解出，赛后看WP学习解法，至少知道下次遇到该类题的大概思路。|_关键点：_ 即使聚焦PWN，也要留意**“性价比”**原则：比赛若有非常简单的非PWN题，花几分钟拿下比苦战高难PWN划算。因此提前准备基本功，有机会就抓住。 _SQLi:_ 牢记常见payload如 `' OR '1'='1` 绕过登录， `' UNION SELECT ...` 抽取数据等。如果已掌握PHP反序列化，那么基础SQLi理应不成问题。 _文件包含:_ PHP中`?file=php://...`等套路，可通过常见题练习。如知道如何包含`php://filter/convert/base64-encode`读取源码。 _APK逆向:_ 不深入，只要会用 jadx 反编译找 Flag 硬编码或者简单逻辑。 _态度:_ 把非PWN题当作调剂和得分手段，不轻视也不花过多时间，做到心中有数即可。|Web漏洞快速笔记：（列举常见Web漏洞）注入技巧指南：参考《SQL注入最简攻略》|
|**4**|**模拟比赛：团队协同练习**（可选，若单人准备可跳过或模拟分工） – **任务：**如果有战队或小组，可一起模拟一次完整CTF挑战，时间设定为一天，涵盖PWN/Web/RE/Crypto各类题。练习团队分工和沟通。 – **流程：**比赛开始，团队快速浏览所有题目，依据每人特长分配题目。主攻PWN的你迅速着手PWN题，其它队友负责其他方向。 – **沟通：**中途定时交流进展，如PWN有突破需多久，Web是否卡住需要支援等。你也可在PWN告一段落时协助简单的Web/RE，体现团队合作。 – **目的：**体验真实CTF团队赛氛围，学会**任务分配和时间管理**。也许某PWN题非常难，决定放弃转投Web题也是战略之一。通过模拟找出团队合作的问题，比如信息未及时共享、精力分配不合理等。 – **总结：**赛后团队一起复盘每题，交流不同领域题目的经验，相互学习提升。|_关键点：_ **团队赛策略**：不同于单打独斗，团队要善于根据难度调整资源。例如当你解决PWN空档，可以帮队友跑脚本或爆破密码，提高整体效率。 _信息共享:_ 及时在团队聊天中报告发现，比如你泄露了某服务的密码，也许Crypto队友就可用上。 _取舍:_ 如果一道PWN耗费太久没有头绪，要敢于建议团队暂放弃，先抢其它题的分。 _心理:_ 感受团队合作的乐趣和压力。比赛时队友可能急问“PWN还有戏吗？”，要能在压力下冷静评估。如果的确无进展，要有勇气承认并改变策略，这也是成熟的表现。 _个人成长:_ 从团队成员处学到别的方向的新知识，如看到队友用Burp抓包搞Web，也许你会对Web调试更有概念。最终成长为全栈选手。|团队配合指南：（强调组队不同方向优势互补）CTF比赛心得：博客《CTF团队比赛经验分享》|
|**5**|**赛前冲刺计划制定：** – 比赛在即（一周左右），制定详细的赛前每日计划。例如每天快速重温一遍笔记中PWN技巧列表；拿出几道以前做过的题目重新做一遍以热身（特别是比赛Morning，做道小题找感觉）。 – 准备比赛环境：整理好**工具箱**：常用Exploit脚本模板、常用字典、漏洞利用脚本（如常见加解密脚本）等离线可及。确保调试工具版本符合比赛要求（如要求自己电脑，不连网则提前下好离线资料）。 – 心态调整：最后几天不要再钻研全新高难内容，以**巩固**为主。保证规律作息，避免熬夜。可适度运动或放松，使大脑在比赛日达到最佳状态。 – 仪式感：准备好比赛当天需要的物品：纸笔（手算记录用）、幸运物件等。提前了解比赛规则和平台操作，避免临场技术性失误。|_关键点：_ **临阵不磨枪**：赛前应该停止大强度学习，转为温习和心理调适。“磨刀不误砍柴工”，好状态比多学一点点新知识更重要。 _整理工具:_ 检查VPN/代理（如题目服务器需要）、测试网络速度。如有自己的脚本库，离线保存一份以防现场没网。设置好本地虚拟机/容器，比赛时快速搭建环境。 _模拟流程:_ 在脑中过一遍比赛流程：拿到题先做什么、预估每题用时、遇到卡点怎么决策等。这样比赛时更从容，避免慌乱。 _团队沟通:_ 若有队伍，最后碰头会明确分工和应急策略（如某人电脑出问题另有人顶上）。 _自信:_ 回顾两个月来的努力和成长，相信自己的准备。保持平常心，视比赛为一次检验和学习机会，成败得失都坦然面对，这样反而发挥更佳。|赛前清单参考：[知乎]比赛前要准备什么心理建设：（以平常心对待CTF的心态建议）|
|**6**|**比赛日 (Day1)：** – 充分休息后上场，按照既定策略行事。优先扫描所有题目，标记出可下手的**中等PWN题**和明显简单的其他题。 – 先从自己最有把握的入手，如一道典型栈溢出，力争半小时到1小时内搞定，拿下首血增强信心。 – 然后逐个攻克目标PWN题，同时关注比赛动态（如官方可能发布提示，要及时留意）。 – 与队友保持沟通。如果PWN卡住，而队友在Web也卡住，可以考虑切换支援。务必根据实际进展灵活调整分工。 – Day1结束前，整理尚未解决的题目，分析原因，准备Day2冲刺（如有Day2的话）。如果是单日赛，则全力以赴直到最后一刻，不放弃任何可能get flag的机会。|_关键点：_ **临场发挥**：严格按照演练过的节奏，不要轻易panic。遇到出错，冷静debug，一步步排除问题。 _Flag提交:_ 每拿到一个flag立即提交，不拖延。注意格式精确，避免因格式错误失分。 _资源利用:_ 善用比赛提供的资源，如FAQ、Hint、比赛群聊等。有疑问比如服务挂掉应马上向主办反馈。 _时间管理:_ 切忌在单一道题上耗费过久。如果2-3小时都无进展且分值不高，应先放下去尝试别题，或干脆休息一下（走走喝水）换脑。 _赛场学习:_ 关注动态排名，学习领先队伍可能擅长的方向。比赛也是学习机会，感受顶尖选手的节奏，提高自己的眼界。|官方比赛守则/提示团队配合强调：（合理练习有助实战发挥）|
|**7**|**比赛日 (Day2) 及赛后：** – 如果比赛有Day2，延续Day1策略，同时针对剩余未解题目重点突破。此时可能题目所剩不多且多为难题，要有心理准备但不轻言放弃。 – 可尝试一些非常规手段，如对服务暴力Fuzz、猜测漏洞点，或使用比赛平台的提示资源。 – 比赛结束后，不论成绩如何，务必收集全部官方Writeups和他人Writeup，作为宝贵学习资料。 – **赛后总结：**静心回顾比赛表现：哪些题型顺利拿下（说明准备充分），哪些失分（找出知识盲区或失误原因）。制定后续学习计划，巩固薄弱环节。 – 调整状态：经过两月高强度训练，可适当休整。但CTF学习是长期过程，赛后更应保持热情，不断提高，为今后更高水平比赛做准备。|_关键点：_ **永不停止学习：**CTF是没有止境的，赛后要持续跟进行业新技术和新题型。可以考虑读更高级的安全书籍、关注安全漏洞情报，不断扩充自己的知识面。 _社区交流:_ 如果有条件，多参加CTF论坛/QQ群，与其他CTFer交流经验。分享你这次备赛的心得，也可从别人那里获得宝贵建议。 _成就感:_ 无论比赛结果如何，完成这段冲刺已是很大进步。好成绩当然值得庆贺；若有不足，也不气馁，把它转化为动力。 _持续练习:_ 建议保持刷题习惯。比赛不是终点，而是新的起点。可把这两月的计划精简为日常每周练习，持续提高实力。 _平衡:_ 也要注意平衡学习与生活、学业的关系。通过CTF掌握的技能在学业和职业上也有帮助，要学以致用，全面发展。|赛后Writeup重要性：（提及赛后看WP继续学习）持续提升：参考“CTF进阶路线”指导|
