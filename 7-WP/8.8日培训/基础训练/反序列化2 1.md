## **共性原理**

三种方案本质都是利用：

1. **有目标类** `**test**` **带危险** `**__destruct()**`，且我们能通过 `unserialize()` 创建。
    
2. 将 `test` 对象放在反序列化结构的 **前面**，保证它被先创建。
    
3. 在构造 **后续元素** 时，用一个“反序列化阶段会抛异常 / 致命中止的类”打断 `unserialize()`。
    
4. `unserialize()` 被中断时，前面已经创建的 `test` 对象失去引用，**在栈回退时调用** `**__destruct()**`，于是执行 `cat /flag`。
    
5. 因为异常发生在 `unserialize()` 内部，代码里的 `throw new Exception('lose')` 根本执行不到。
    

---

## **方案 B – ReflectionClass 校验类型**

**Payload**：

```php
a:2:{i:0;O:4:"test":0:{}i:1;O:16:"ReflectionClass":1:{s:4:"name";i:1;}}
```

**原理**：

- `ReflectionClass` 在反序列化时要求 `name` 是合法字符串类名。
    
- 我们给整型 `1`，直接触发内部抛异常。
    
- 稳定性高，PHP 7/8 都常用。
    

---

## **方案 C – SplDoublyLinkedList 破坏状态**

**Payload**：

```php
a:2:{i:0;O:4:"test":0:{}i:1;C:19:"SplDoublyLinkedList":4:{boom}}
```

**原理**：

- `C:...` 形式调用类的 `unserialize()` 方法。
    
- `SplDoublyLinkedList` 内部实现对数据格式要求极严。
    
- 给它非法数据 `boom` 会直接抛异常/致命中止。
    
- 好处：很多 PHP 版本内置这个类，命中率高。
    

---

## **方案 E – PDO 禁止反序列化**

**Payload**：

```php
a:2:{i:0;O:4:"test":0:{}i:1;O:3:"PDO":0:{}}
```

**原理**：

- `PDO` 对象反序列化在 PHP 默认是禁止的（内部直接抛异常）。
    
- 因此一进入构造就爆。
    
- 简洁稳定，但要求 PHP 编译了 PDO。
    

---

## **稳定性对比**

| 方案  | 依赖类                 | 出异常原因    | 跨版本稳定性      | 常见度 |
| --- | ------------------- | -------- | ----------- | --- |
| B   | ReflectionClass     | 属性类型不符   | 高（PHP 5.4+） | 高   |
| C   | SplDoublyLinkedList | 数据格式错误   | 高           | 高   |
| E   | PDO                 | 内部禁止反序列化 | 高（开启 PDO）   | 中   |

---

## **防御思路**