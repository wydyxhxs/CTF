GOT ：Global Offset Table，全局偏移表
PLT：Procedure Linkage Table，过程链接表

查看.got和.got.plt等地址（无PIE）：
gdb
```bash
info files
```

# libc 利用套路速查表

## 1. **No RELRO：GOT 覆写**

- **条件**：程序没开 RELRO（或者 Partial RELRO），`.got.plt` 可写。
    
- **方法**：
    
    1. 泄露或知道 `system` 地址。
        
    2. 用漏洞写内存，把某函数（如 `puts@GOT`）改成 `system`。
        
    3. 再调用 `puts("sh")` → 实际变成 `system("sh")`。
        
- **优点**：payload 简单，往往一发入魂。
    
- **缺点**：如果 Full RELRO 开启，GOT 变成只读，就不能用了。
    

---

## 2. **ret2libc（经典方式）**

- **条件**：堆栈可控，可以构造 ROP；一般需要能“泄露 libc 地址”。
    
- **方法**：
    
    1. 泄露 libc 中任意函数（比如 `puts@got`）的实际地址。
        
    2. 根据已知 libc 版本的符号表，算出 **libc 基址**。
        
        `libc_base = leaked_puts - libc.symbols['puts']`
        
    3. 根据基址 + 偏移，拿到 `system` 和 `"/bin/sh"` 字符串地址。
        
    4. 构造 ROP 调用 `system("/bin/sh")`。
        
- **优点**：通用性最强，几乎所有题都能用。
    
- **缺点**：需要信息泄露，且需要知道 libc 的版本。
    

---

## 3. **one_gadget**

- **条件**：知道 libc 版本，能控制 RIP/EIP。
    
- **方法**：
    
    1. 用 `one_gadget libc.so.6` 工具找出满足条件的 gadget 偏移。
        
    2. 泄露 libc 基址。
        
    3. 跳到 `libc_base + one_gadget_offset`。
        
- **优点**：payload 短小，通常只需一次跳转就能 getshell。
    
- **缺点**：one_gadget 有**约束条件**（如 `rsp+0x30 == NULL`），并不一定能满足。
    

---

## 4. **ret2csu（或 ret2dlresolve）**

- **适用场景**：
    
    - ret2csu：程序里没有现成的 `pop rdi` 等 gadgets，需要用 `__libc_csu_init` 中的 gadget 来构造任意函数调用。
        
    - ret2dlresolve：程序没有 `system` 或者缺少某些符号，可以伪造一个 `dl_resolve` 结构来调用动态链接器解析任意函数（如 `system`）。
        
- **优点**：解决 gadget 不全、符号缺失的问题。
    
- **缺点**：payload 比较复杂，一般是进阶题。
    

---

## 5. **Format String + libc**

- **条件**：存在格式化字符串漏洞。
    
- **方法**：
    
    1. 用 `%p` / `%s` 等泄露 GOT/栈/返回地址，进而泄露 libc。
        
    2. 用 `%n` 往 GOT 写入 `system` 地址。
        
    3. 或者直接构造 ROP 跳 libc。
        
- **优点**：格式化字符串题里几乎必用套路。
    
- **缺点**：需要仔细算偏移，容易调试半天。
    

---

## 📌 适用场景速查

|场景|最优解|
|---|---|
|**No RELRO**|GOT 覆写|
|**Partial/Full RELRO** + 可泄露地址|ret2libc|
|**Full RELRO** + 没有现成 gadget|ret2csu / ret2dlresolve|
|**已知 libc，能控 RIP**|one_gadget|
|**格式化字符串漏洞**|泄露 libc + GOT 改写 / ret2libc|

---

## 🚀 小技巧

- **确认 libc 版本**：
    
    - 本地 `ldd ./pwn` → 找到 `libc.so.6` 路径。
        
    - 或远程爆破 libc 版本（用 `libc-database`）。
        
- **pwntools 脚本常用**：
    
    `from pwn import * elf = ELF('./pwn') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # 或libc-database匹配到的版本  # 泄露puts地址 puts_got = elf.got['puts'] puts_plt = elf.plt['puts']  # 计算基址 libc_base = leaked_puts - libc.symbols['puts'] system = libc_base + libc.symbols['system'] binsh = libc_base + next(libc.search(b"/bin/sh"))`
    
- **one_gadget 使用**：
    
    `one_gadget libc.so.6`